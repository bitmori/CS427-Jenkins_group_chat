/**
 * @file ClientListingTest.java
 *
 * @author Timothy Madigang, Ke Yang, Joseph Ciurej
 * @date 04/12/2013
 *
 * @TODO
 * - Expand tests to include saving and loading from arbitrary locations
 *   to better cover boundary cases.
 * - Move the 'delete' function to a better-fitting type (some form of
 *   file I/O namespace type).  This code doesn't really belong within
 *   a testing class.
 */
package edu.illinois.t25;

import edu.illinois.t25.data.*;
import org.junit.Test;
import org.junit.After;
import org.junit.Before;
import static org.junit.Assert.*;

import java.io.File;
import java.io.FileWriter;
import java.io.BufferedWriter;
import java.io.PrintWriter;
import java.io.IOException;
import java.net.InetAddress;
import java.net.SocketAddress;
import java.net.InetSocketAddress;
import java.net.UnknownHostException;

/**
 * Container class for the test suite that tests the functionality of the 
 * "ClientListingTest" type.
 */
public class ClientListingTest
{
	/// Testing Constants ///
	
	/**
	 * The directory in which all the listing test files will are stored.
	 */
	private final static File csTestDirectory = new File( "./test-list" );

	/**
	 * A reference to the test listing generated by the setup function.
	 * This listing serves as the axiomatic/clean listing.
	 */
	private final static File csTestListingFile = new File( "./test-list/test_listing.csv" );

	/**
	 * A reference to an unused socket address used in testing.  This
	 * address is used to verify that no odd addresses are contained
	 * in the test listing.
	 */
	private final static SocketAddress csTestUnusedAddr = new InetSocketAddress( "198.9.2.0", 80 );

	/// Testing Variables ///

	/**
	 * The listing object on which all the correctness tests are performed.
	 */
	private ClientListing mTestListing = null;

	/**
	 * A listing of test users that will be referred to during testing.
	 */
	private final JenkinsUser[] mTestUsers = new JenkinsUser[2];

	/**
	 * A parallel listing to `mTestUsers` that contains the test addresses for 
	 * the test users.
	 */
	private final SocketAddress[] mTestAddrs = new SocketAddress[2];

	/// Testing Set Up/Tear Down ///
	
	/**
	 * Initializes the test listing by creating a clean client listing file
	 * and constructing a client listing using this file.
	 *
	 * @throws IOException An exception is thrown if the test executable doesn't
	 *  have permissions to create the testing files/directories.
	 * @throws SecurityException An exception is thrown if the test executable doesn't
	 *  have permissions to create the testing files/directories.
	 * @throws UnknownHostException An exception that's thrown if the address of
	 *  the local machine cannot be resolved.
	 */
	@Before
	public void TestSetup() throws IOException, UnknownHostException, SecurityException
	{
		csTestDirectory.mkdir();
		csTestListingFile.createNewFile();

		mTestUsers[0] = new JenkinsUser( "John", InetAddress.getByName("127.0.0.1"), "A" );
		mTestAddrs[0] = new InetSocketAddress( mTestUsers[0].getAddressInet(), 2000 );
		mTestUsers[1] = new JenkinsUser( "Matt", InetAddress.getByName("192.168.1.3"), "B" );
		mTestAddrs[1] = new InetSocketAddress( mTestUsers[1].getAddressInet(), 2000 );

    	PrintWriter fileWriter = new PrintWriter(
			new BufferedWriter(new FileWriter(csTestListingFile)) );
		for( int userIdx = 0; userIdx < mTestUsers.length; ++userIdx )
		{
			JenkinsUser testUser = mTestUsers[ userIdx ];
			SocketAddress testAddr = mTestAddrs[ userIdx ];
			String userString = testUser.getName() + "," + testUser.getGroup() + 
				"," + testAddr.toString();

			fileWriter.println( userString );
		}
		fileWriter.close();

		mTestListing = new ClientListing( csTestListingFile.getPath() );
	}

	/**
	 * Removes the constructed client listing file and any other output test
	 * files by the test suite.
	 *
	 * @throws IOException An exception is thrown if the test executable doesn't
	 *  have permissions to delete the testing files/directories.
	 */
	@After
	public void TestTeardown() throws IOException
	{
		delete( csTestDirectory );
	}

	/// Testing Functions ///

	@Test
	public void TestConstructor() throws UnknownHostException
	{
		assertEquals( "Client listing should contain first entry client in input file.",
			mTestUsers[0], mTestListing.getClientAt( mTestAddrs[0] ) );
		assertEquals( "Client listing should contain all entry clients in input file.",
			mTestUsers[1], mTestListing.getClientAt( mTestAddrs[1] ) );

		assertEquals( "Client listing shouldn't contain additional clients.",
			null, mTestListing.getClientAt( csTestUnusedAddr ) );
	}

	@Test
	public void TestAddClient() throws UnknownHostException
	{
		InetAddress newUserAddr = InetAddress.getByName("190.168.1.4");
		SocketAddress newUserSockAddr = new InetSocketAddress( newUserAddr, 2000 );
		JenkinsUser newUser = new JenkinsUser( "Carl", newUserAddr, "C" );
		mTestListing.add( newUserSockAddr, newUser );

		assertTrue( "Added client should have its address listed in the listing.",
			mTestListing.listed( newUserSockAddr ) );
		assertTrue( "Added client should have its user name listed in the listing.",
			mTestListing.listed( newUser.getName() ) );

		assertEquals( "Added client should have an identical entry in the listing.", 
			newUser, mTestListing.getClientAt( newUserSockAddr ) );
		assertEquals( "Added client should be accessible through user name access.", 
			newUserSockAddr, mTestListing.getClientNamed( newUser.getName() ) );
	}

	@Test
	public void TestAddRedundantClient() throws UnknownHostException
	{
		InetAddress usedAddr = mTestUsers[0].getAddressInet();
		JenkinsUser redundantUser = new JenkinsUser( "Bill", usedAddr, "D" );
		mTestListing.add( mTestAddrs[0], redundantUser );

		assertTrue( "Redundant key adding shouldn't remove the address from the listing.",
			mTestListing.listed( mTestAddrs[0] ) );
		assertTrue( "Redundant key adding shouldn't remove the user name from the listing.",
			mTestListing.listed( mTestUsers[0].getName() ) );
		assertFalse( "Redundant key adding shouldn't add the user name of the redundant entry.",
			mTestListing.listed( redundantUser.getName() ) );
		
		assertEquals( "Redundant adding should retain the previous client for the address.",
			mTestUsers[0], mTestListing.getClientAt( mTestAddrs[0] ) );
		assertEquals( "Redundant adding should retain the previous client for the user name.",
			mTestAddrs[0], mTestListing.getClientNamed( mTestUsers[0].getName() ) );
	}

	@Test
	public void TestSaveListing() throws UnknownHostException
	{
		InetAddress newUserAddr = InetAddress.getByName("190.168.1.4");
		SocketAddress newUserSockAddr = new InetSocketAddress( newUserAddr, 2000 );
		JenkinsUser newUser = new JenkinsUser( "Carl", newUserAddr, "C" );
		mTestListing.add( newUserSockAddr, newUser );
		
		String newListingPath = "./test-list/new_listing.csv";
		mTestListing.save( newListingPath );
		ClientListing newListing = new ClientListing( newListingPath );

		assertTrue( "Client listing should save all contained clients to file.",
			newListing.listed(mTestAddrs[0]) &&
			newListing.listed(mTestAddrs[1]) &&
			newListing.listed(newUserSockAddr) );

		assertTrue( "Client listing should save all contained clients with same fields.",
			mTestUsers[0].equals( newListing.getClientAt(mTestAddrs[0]) ) &&
			mTestUsers[1].equals( newListing.getClientAt(mTestAddrs[1]) ) &&
			newUser.equals( newListing.getClientAt(newUserSockAddr) ) );

		assertEquals( "Client listing shouldn't save extraneous clients.",
			null, newListing.getClientAt( csTestUnusedAddr ) );
	}

	/// Helper Functions ///

	/**
	 * Deletes the file entity represented by the given file handle, recursively
	 * performing deletion if the file entity is a non-mepty directory.
	 *
	 * @param pFile The file handle that refers to the file entity that will be
	 *  completely removed from the file system.
	 *
	 * @throws IOException Thrown if the executing method doesn't have proper
	 *  permissions to delete the entity referenced by the given file handle.
	 *
	 * @see "http://www.mkyong.com/java/how-to-delete-directory-in-java/"
	 */
    public static void delete( File pFile ) throws IOException
	{
		if( pFile.isDirectory() )
		{
			String directoryFilePaths[] = pFile.list();
			for( String filePath : directoryFilePaths )
			{
				File containedFile = new File( pFile, filePath );
				delete( containedFile );
			}
		}

		pFile.delete();
    }

}
